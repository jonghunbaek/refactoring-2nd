# Chapter02 - 리팩터링 원칙

## 1. 요약
### 1-1. 리팩터링 정의
- 리팩터링 : [명사] **소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법**
- 리팩터링 : [동사] **소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**
- 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이므로, 단순히 코드를 정리한다고해서 리팩터링이라고 할 수는 없다.
- 리팩터링의 핵심은 **전, 후의 동작 결과가 똑같아야 한다는 것**이다.
  - 성능 관점이 아닌 클라이언트의 관점에서 똑같아야 함을 의미
  - 그러므로 리팩터링 과정에서 발견한 버그는 리팩터링 후에도 존재해야 한다.
### 1-2. 두 개의 모자(기능 추가 모자 vs 리팩터링 모자)
- **기능 추가 모자**
  - 기능 추가는 기존 코드를 건드리지 않고 새 기능을 추가만 한다.
  - 진척도는 테스트를 추가해 통과 여부로 측정
- **리팩터링 모자**
  - 기능 추가는 절대로 하지 않고 오로지 코드 재구성에 집중한다.
  - 테스트도 새로 만들지 않는다.(인터페이스를 변경해야 할 경우만 테스트 수정)
- 핵심은 두 개의 모자의 미묘한 차이를 인지하고 작업 방식에 분명한 차이를 둬야 함
### 1-3. 리팩터링 하는 이유
- **소프트웨어 설계의 향상**
  - 단기 목표만을 위해 코드를 수정하면 기반 구조가 무너져 내부 설계가 썩기 쉽다.
  - 규칙적인 리팩터링이 코드의 구조를 지탱해줄 수 있다.
- **소프트웨어 이해도 향상**
  - 프로그램을 동작시키는 데만 집중한 코드는 나중에 그 코드를 다룰 다른 개발자를 배려하지 못한다.
  - 그리고 그 다른 개발자는 나 자신일 경우가 대부분이다.
- **쉬운 버그 발견**
  - 구조가 명확한 프로그램은 버그를 발견하기 쉬워진다.(코드를 이해하기 쉬워지므로)
- **프로그래밍 속도 향상**
  - 내부 설계가 잘 된 소프트웨어에 새로운 기능을 추가할 땐, 기능 추가 지점과 코드 수정이 필요한 부분을 빠르게 발견할 수 있다.
  - 더불어, 지속적인 리팩터링으로 모듈화가 잘되어 있다면 이해해야 할 부분이 현저히 적어진다.
- 처음부터 완벽하고 좋은 설계를 할 수는 없다. 그러므로 리팩터링을 통해 지속적으로 코드의 구조를 개선하고, 소프트웨어의 구조 부패를 방지하자.
### 1-4. 언제 리팩터링해야 할까?
##### 3의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
  - 리팩터링하기 가장 좋은 시점은 **코드베이스에 기능을 새로 추가하기 직전**이다.
  - 기능 추가 전, 버그를 잡고 중복된 코드를 하나로 합쳐보자.
- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
  - 리팩터링을 통해 머리로 이해한 것을 코드에 옮겨 담자(사람의 머리는 많은 것을 기억하지 못한다.)
  - 깔끔하게 정리된 코드는 정리 전에 보이지 않던 설계를 볼 수 있게 만든다.
  - 코드 분석시 리팩터링을 하면, 하지 않았을 때 보다 더 깊은 수준으로 구조를 이해하게 된다.
- **쓰레기 줍기 리팩터링**
  - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 다소 걸릴 일은 TODO로 정리하여 본 작업을 끝낸 후 처리한다.
  - 리팩터링의 가장 큰 장점인 각각의 작은 단계가 코드를 깨뜨리지 않는 점을 적극 활용하자.(몇 달에 걸친 작업일지라도 문제가 되지 않음)
- **계획된 리팩터링과 수시로 하는 리팩터링**
  - 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 따로 시간을 잡기보단 다른 작업과 병행하자.
  - 보기 싫은 코드만 리팩터링이 필요한 것은 아니다. 잘 작성된 코드 또한 수많은 리팩터링이 필요하다.
  - 계획된 리팩터링이 무조건 나쁘다는 아니다. 하지만 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
  - 리팩터링은 기능 추가와 밀접하게 엮인 경우가 많기에 앞선 두 개의 모자를 활용해 적절하게 작업 방식을 스위칭 하자.
- **오래 걸리는 리팩터링**
  - 몇 주씩 걸리는 대규모 리팩터링의 경우에도 팀 전체가 매달리는 데는 회의적이다.
  - 누구든지 리팩터링해야 할 코드와 관련한 작업을 할 때마다 조금씩 해결해가는 편이 효과적인 경우가 많다.
  - 이는 리팩터링이 코드를 깨트리지 않는 장점을 활용하는 것이다.
- **코드 리뷰에 리팩터링 활용하기**
  - 코드 리뷰를 할 때, 머리속으로만 상상하는 것보다 가능하다면 리팩터링을 해보자. 한 차원 더 높은 아이디어가 떠오를 가능성이 높아진다.
  - 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다.
  - PR모델(작성자랑 같이 리뷰하지 않는)에 해당 방식은 적합하지 않다. 작성자와 같이 코드를 리뷰하며 리팩터링하는 것이 좋다.(짝 프로그래밍)
- **리팩터링하지 말아야 하는 순간**
  - 관리자의 압박이 있는 경우. 이 경우엔 한다고 말하지 말고 몰래 ㄱㄱ(상황에 따라 적절한 방안을 모색해자)
  - 굳이 수정할 필요가 없다면 생략하자. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 본다.
  - 처음부터 새로 작성하는 것이 쉬울 때도 생략하자.(이 부분은 경험에서 얻은 판단력이 필요)
### 1-5. 리팩터링 시 고려할 문제
- **새 기능 개발 속도 저하**
  - 리팩터링의 궁극적인 목적은 개발 속도를 높여, 더 적은 노력으로 더 많은 가치를 창출하는 것
  - 경험에서 나온 판단으로 새 기능 추가를 우선할지, 리팩터링을 우선할지 결정
  - 리팩터링을 도덕적인 이유로 정당화 하지 말자. 리팩터링의 본질은 경제적인 이유다. 
  - 즉, 리팩터링을 옮고 그름의 이분법적인 사고로 판단하지 말고, 여러 비용 손익을 판단해 균형점을 찾자.
- **코드 소유권**
  - 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 것 보단 팀에 둬 누구나 팀이 소유한 코드를 수정할 수 있는 환경을 만들자.
  - 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다.
- **브랜치**
  - 기능 브랜치 방식은 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워지는 단점이 존재한다.
  - 기능별 브랜치의 통합 주기를 가급적 하루 한 번으로 가져가자.(CI - 지속적 통합)
  - 이를 위해 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능 토글을 적용하자.
  - 머지와 통합을 명확하게 구분하자.
    - 머지 : 마스터를 브랜치로 머지하는 단방향 작업
    - 통합 : 마스터를 개인 브랜치로 가져와(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향 작업
  - CI는 리팩터링과 궁합이 좋다.
- **테스팅**
  - 리팩터링의 핵심은 오류를 재빨리 잡는 데 있다. 이를 위해선 자가 테스트 코드가 필반드시 필요하다.
  - 리팩터링 -> 자가 테스트 -> 실패할 경우 최근 통과한 버전과의 차이점 분석 -> 이를 통해 리팩터링 과정에서 버그가 생길 위험에 대한 불안감을 해소
  - 안전한 자동 리팩터링(인텔리제이의 변수명 변경, 함수명 변경과 같은)을 활용하는 경우, 테스트 없이 리팩터링해도 괜찮다.
- **레거시 코드**
  - 레거시 시스템을 파악할 땐 리팩터링이 굉장히 도움이 된다. 하지만 대규모 시스템을 테스트 코드 없이 명료하게 리팩터링하는 것은 어렵다.
  - 결국 레거시 코드를 리팩터링하는 것도 테스트를 보강하는 것이 핵심이다. 테스트하기 어려운 경우라도 최대한 틈새를 찾아 시스템을 테스트해야 한다.
  - 자주 보는 부분을 우선적으로 리팩터링 하자.
- **데이터베이스**
  - 진화형 데이터 베이스 설계, 데이터베이스 리팩터링 기법을 적용하자.
    - 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 것이 핵심
  - 다른 리팩터링과 마찬가지로 해당 기법도 전체 변경 과정을 작고 독립적인 단계들로 쪼개는 것이 핵심이다.
  - 다만 프로덕션 환경에서 여러 단계로 나눠 릴리스하는 것이 대체로 좋다는 점이 다른 리팩터링과 다르다.
### 1-6. 리팩터링 아키텍처, 애그니(YAGNI - You Aren't Going to Neet It)
  - 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해주는 것에 있다.
  - 처음부터 모든 요구사항을 만족하는 설계는 없다. 대신 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두자.
    - 하지만 무분별한 사용은 오히려 변화에 대응하는 능력을 떨어뜨릴 수 있다.
    - 리팩터링을 활용해 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축하자.  
    - 복잡도에 지장을 주지 않는 메커니즘은 자유롭게 추가해도 되지만 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가하자.
    - 예상되는 변경을 미리 반영하는 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가하자.
  - 이러한 설계 방식을 간결한 설계, 점진적 설계, YAGNI라고 부른다.
  - 이러한 방식이 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다. 다만 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다.
### 1-7. 리팩터링과 소프트웨어 개발 프로세스
  - 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷밤침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.
  - 이를 위해 자가 테스트 코드, 지속적 통합, 리팩터링이란 세 기법을 활용해 강력한 상승 효과를 발휘하자.
  - 위 세 가지 기법과 YAGNI는 서로 긍정적인 영향을 주며, 수많은 유연성 메커니즘을 갖춘 시스템보다 변화에 기민하게 대응할 수 있다.
  - 설명은 간단하지만 실무에 적용하기는 만만치 않기에 충분한 연습과 실력이 뒷받침 되어야 한다.
### 1-8. 리팩터링과 성능
  - 리팩터링 후에 소프트웨어가 느려질 수도 있는 것은 사실이지만 그와 동시에 성능을 튜닝하기는 더욱 쉬워진다.
  - 저자가 경험한 빠른 소프트웨어 작성 방법 세 가지
    - 가장 엄격한 방법인 시간 예산 분배 방식(하드 리얼타임 시스템) - 시스템을 여러 컴포넌트로 나눠 컴포넌트마다 자원(시,공간)예산을 할당
    - 끊임없이 관심 기울이기 - 직관적이지만 실제 효과는 변변치 않음
    - 성능 최적화 작업 전까지 성능 보단 다루기 쉬운 코드 작성하기
      - 대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.(코드 전체에 대한 최적화는 사실상 90%는 효과가 없는 셈)
  - 프로그램의 리팩터링을 잘 해두면 세 번째 방식에서 두 가지 도움을 준다.
    - 성능 튜닝에 투입할 시간을 벌 수 있다.
    - 성능을 더 세밀하게 분석할 수 있다.
### 1-9. 리팩터링의 유래
  - 정확한 유래는 찾을 수 없다.
  - 리팩터링의 중요함을 깨달은 선구자들인 워드 커닝햄과 켄트 백이 1980년대부터 스몰토크를 활용해 개발해왔다.
### 1-10. 리팩터링 자동화
  - IDE(인텔리제이, 이클립스 등)와 같은 플랫폼에선 리팩터링 자동화 도구를 지원해준다.
  - 이러한 도구들은 별도의 테스트가 필요 없을 정도로 안정적이다. 
  - 리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다.
  - 자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다.
  - 테스트를 활용해 자동, 수동 리팩터링을 함께 사용하자.

## 2. 리뷰
- 리팩터링의 핵심은 테스트 코드, 작은 변경, 동일 결과라고 볼 수 있을 것 같다.
- 그 동안 내가 해왔던 리팩토링은 분명 코드 구조를 개선했지만 작은 변경과 동일 결과라는 핵심을 지키지 못했다.
- 그렇기에 리팩터링은 꽤나 수고스럽고, 시간 비용이 많이 들어가는 작업이었다.
- 리팩터링은 비용에 대한 트레이드 오프에서 이뤄져야 하고, 작은 단위로 그리고 수시로 수행되어야 한다.
- 실무에서 마주하는 무수한 케이스를 고려한다면 절대적인 규칙은 존재할 수 없다. 
- 결국 다양한 경험과 깊은 고민에서 얻는 인사이트를 가져야 한다. 
- 다시 말해 이 책을 읽는다고 달라지는 것은 없다. 책에서 배운 내용을 토대로 내 코드를 끊임없이 리팩터링해보는 것이 유일한 변화의 지름길이다.