# Chapter02 - 리팩터링 원칙

## 1. 요약
### 1-1. 리팩터링 정의
- 리팩터링 : [명사] **소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법**
- 리팩터링 : [동사] **소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.**
- 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이므로, 단순히 코드를 정리한다고해서 리팩터링이라고 할 수는 없다.
- 리팩터링의 핵심은 **전, 후의 동작 결과가 똑같아야 한다는 것**이다.
  - 성능 관점이 아닌 클라이언트의 관점에서 똑같아야 함을 의미
  - 그러므로 리팩터링 과정에서 발견한 버그는 리팩터링 후에도 존재해야 한다.
### 1-2. 두 개의 모자(기능 추가 모자 vs 리팩터링 모자)
- **기능 추가 모자**
  - 기능 추가는 기존 코드를 건드리지 않고 새 기능을 추가만 한다.
  - 진척도는 테스트를 추가해 통과 여부로 측정
- **리팩터링 모자**
  - 기능 추가는 절대로 하지 않고 오로지 코드 재구성에 집중한다.
  - 테스트도 새로 만들지 않는다.(인터페이스를 변경해야 할 경우만 테스트 수정)
- 핵심은 두 개의 모자의 미묘한 차이를 인지하고 작업 방식에 분명한 차이를 둬야 함
### 1-3. 리팩터링 하는 이유
- **소프트웨어 설계의 향상**
  - 단기 목표만을 위해 코드를 수정하면 기반 구조가 무너져 내부 설계가 썩기 쉽다.
  - 규칙적인 리팩터링이 코드의 구조를 지탱해줄 수 있다.
- **소프트웨어 이해도 향상**
  - 프로그램을 동작시키는 데만 집중한 코드는 나중에 그 코드를 다룰 다른 개발자를 배려하지 못한다.
  - 그리고 그 다른 개발자는 나 자신일 경우가 대부분이다.
- **쉬운 버그 발견**
  - 구조가 명확한 프로그램은 버그를 발견하기 쉬워진다.(코드를 이해하기 쉬워지므로)
- **프로그래밍 속도 향상**
  - 내부 설계가 잘 된 소프트웨어에 새로운 기능을 추가할 땐, 기능 추가 지점과 코드 수정이 필요한 부분을 빠르게 발견할 수 있다.
  - 더불어, 지속적인 리팩터링으로 모듈화가 잘되어 있다면 이해해야 할 부분이 현저히 적어진다.
- 처음부터 완벽하고 좋은 설계를 할 수는 없다. 그러므로 리팩터링을 통해 지속적으로 코드의 구조를 개선하고, 소프트웨어의 구조 부패를 방지하자.
### 1-4. 언제 리팩터링해야 할까?
##### 3의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
- **준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**
  - 리팩터링하기 가장 좋은 시점은 **코드베이스에 기능을 새로 추가하기 직전**이다.
  - 기능 추가 전, 버그를 잡고 중복된 코드를 하나로 합쳐보자.
- **이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기**
  - 리팩터링을 통해 머리로 이해한 것을 코드에 옮겨 담자(사람의 머리는 많은 것을 기억하지 못한다.)
  - 깔끔하게 정리된 코드는 정리 전에 보이지 않던 설계를 볼 수 있게 만든다.
  - 코드 분석시 리팩터링을 하면, 하지 않았을 때 보다 더 깊은 수준으로 구조를 이해하게 된다.
- **쓰레기 줍기 리팩터링**
  - 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 다소 걸릴 일은 TODO로 정리하여 본 작업을 끝낸 후 처리한다.
  - 리팩터링의 가장 큰 장점인 각각의 작은 단계가 코드를 깨뜨리지 않는 점을 적극 활용하자.(몇 달에 걸친 작업일지라도 문제가 되지 않음)
- **계획된 리팩터링과 수시로 하는 리팩터링**
  - 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다. 따로 시간을 잡기보단 다른 작업과 병행하자.
  - 보기 싫은 코드만 리팩터링이 필요한 것은 아니다. 잘 작성된 코드 또한 수많은 리팩터링이 필요하다.
  - 계획된 리팩터링이 무조건 나쁘다는 아니다. 하지만 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야 한다.
  - 리팩터링은 기능 추가와 밀접하게 엮인 경우가 많기에 앞선 두 개의 모자를 활용해 적절하게 작업 방식을 스위칭 하자.
- **오래 걸리는 리팩터링**
  - 몇 주씩 걸리는 대규모 리팩터링의 경우에도 팀 전체가 매달리는 데는 회의적이다.
  - 누구든지 리팩터링해야 할 코드와 관련한 작업을 할 때마다 조금씩 해결해가는 편이 효과적인 경우가 많다.
  - 이는 리팩터링이 코드를 깨트리지 않는 장점을 활용하는 것이다.
- **코드 리뷰에 리팩터링 활용하기**
  - 코드 리뷰를 할 때, 머리속으로만 상상하는 것보다 가능하다면 리팩터링을 해보자. 한 차원 더 높은 아이디어가 떠오를 가능성이 높아진다.
  - 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다.
  - PR모델(작성자랑 같이 리뷰하지 않는)에 해당 방식은 적합하지 않다. 작성자와 같이 코드를 리뷰하며 리팩터링하는 것이 좋다.(짝 프로그래밍)
- **리팩터링하지 말아야 하는 순간**
  - 관리자의 압박이 있는 경우. 이 경우엔 한다고 말하지 말고 몰래 ㄱㄱ(상황에 따라 적절한 방안을 모색해자)
  - 굳이 수정할 필요가 없다면 생략하자. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 본다.
  - 처음부터 새로 작성하는 것이 쉬울 때도 생략하자.(이 부분은 경험에서 얻은 판단력이 필요)
### 1-5. 리팩터링 시 고려할 문제
- **새 기능 개발 속도 저하**
  - 리팩터링의 궁극적인 목적은 개발 속도를 높여, 더 적은 노력으로 더 많은 가치를 창출하는 것
  - 경험에서 나온 판단으로 새 기능 추가를 우선할지, 리팩터링을 우선할지 결정
  - 리팩터링을 도덕적인 이유로 정당화 하지 말자. 리팩터링의 본질은 경제적인 이유다. 
  - 즉, 리팩터링을 옮고 그름의 이분법적인 사고로 판단하지 말고, 여러 비용 손익을 판단해 균형점을 찾자.
- **코드 소유권**
  - 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 것 보단 팀에 둬 누구나 팀이 소유한 코드를 수정할 수 있는 환경을 만들자.
  - 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용할 수 있다.
- **브랜치**
  - 기능 브랜치 방식은 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워지는 단점이 존재한다.
  - 기능별 브랜치의 통합 주기를 가급적 하루 한 번으로 가져가자.(CI - 지속적 통합)
  - 이를 위해 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개고, 각 기능을 끌 수 있는 기능 토글을 적용하자.
  - 머지와 통합을 명확하게 구분하자.
    - 머지 : 마스터를 브랜치로 머지하는 단방향 작업
    - 통합 : 마스터를 개인 브랜치로 가져와(pull) 작업한 결과를 다시 마스터에 올리는(push) 양방향 작업
  - CI는 리팩터링과 궁합이 좋다.
- **테스팅**
- 


## 2. 리뷰
- 리팩터링의 핵심은 테스트 코드, 작은 변경, 동일 결과라고 볼 수 있을 것 같다.
- 그 동안 내가 해왔던 리팩토링은 분명 코드 구조를 개선했지만 작은 변경과 동일 결과라는 핵심을 지키지 못해 작업이 늘어졌다.
- 리팩터링의 실력은 결국 많은 코드를 심사숙고하며 작성하고, 그 구조를 끊임없이 개선하려는 노력을 통해 성장할 수 있다. 즉, 깊은 고민을 한 경험이 많을수록 좋을듯?