# Chapter03 - 코드에서 나는 악취

## 1. 요약
리팩터링을 언제 시작하고, 언제 그만할지를 판단하는 일은 매우 중요하다. 
명확하게 정립된 규칙은 없지만 저자와 켄트 벡은 '냄새'라는 표현으로 리팩터링할 시점을 정립한다.
언제 멈출지에 대한 기준은 제시하지 않는다. 다만, 숙련된 사람의 직관이 가장 정확한 기준이 될 것이다. 
### 1-1. 기이한 이름
- 코드는 단순 명료하게 작성해야 하며, 이를 위해선 '이름'이 가장 중요한 요소다. 
- 그 이유는 이름만 잘 지어도 나중에 코드 문맥을 쉽게 파악할 수 있기 때문이다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 존재할 가능성이 높다. 
### 1-2. 중복 코드
- 코드가 중복되면 각각의 차이점을 주의깊게 살펴야 하는 부담이 생긴다. 
- 코드가 중복될 땐, **함수 추출하기**(6.1)와 같은 기법을 적용하자.
- 만약 비슷한데 완전히 똑같지 않다면 비슷한 부분을 **문장 슬라이스**(8.6)로 모아 함수 추출을 하자.
- 자식 클래스들에 코드가 중복되어 있다면 각자 호출되지 않도록 **메서드 올리기**(12.1)를 적용하자.
### 1-3. 긴 함수
- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
- 이러한 코드는 끝없이 위임하는 방식으로 구성되어 있다. 
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 이 부분에서도 역시 '이름'이 중요한 요소다.
- 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다.
- 무엇을 하는지를 코드가 잘 설명 못할수록 함수로 만드는 것이 유리하다.
- 함수 추출하기에 가장 방해되는 것은 매개 변수와 임시 변수다. 
- 함수 추출하기에 앞서 **임시 변수를 질의 함수로 바꾸기**(7.4), **매개변수 객체 만들기**(6.8), **객체 통째로 넘기기**(11.9)를 선행하자.
- 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많고, 이러한 부분이 함수로 추출하기에 적합한 부분이다.
- 반복문을 함수로 추출하여 이름 짓기가 어려운 것은 성격이 다른 두 가지 작업이 섞여 있기 때문이다.
### 1-4. 긴 매개변수 목록
- 매개 변수 목록이 길어지면 이해하기 어려운 경우가 많다. 
- **매개변수를 질의 함수로 바꾸기**(11.5) 또는 객체 전달을 활용하자.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**(11.3)로 없애자.
- 여러 개의 함수가 특정 매개변수의 값을 공통적으로 사용한다면 **여러 함수를 클래스로 묶기**(6.9)를 활용하자.
### 1-5. 전역 데이터
- 전역 데이터는 코드베이스 어디서든 접근 가능하고, 누가 값을 바꿨는지 찾아낼 메커니즘이 없다.
- 전역 데이터가 가변이라면 특히 다루기 까다롭다.
- 이를 방지하기 위한 대표적인 리팩터링은 **변수 캡슐화 하기**(6.6)다.
- 또한 언어 레벨에서 값이 바뀌지 않음을 보장하는 기능이 존재해야 한다.
### 1-6. 가변 데이터
- 데이터 변경 후 예상하지 못한 곳에서 버그가 발생하는 경우가 종종 있다.
- 아주 드문 조건에서만 발생하다면 더욱 원인을 알아내기 어렵다. 
- **변수 캡슐화 하기**(6.6)을 적용해 함수를 거쳐야만 값을 수정할 수 있도록 하자.
- 하나의 변수에 용도가 다른 값을 저장하기 위해 값을 변경한다면 **변수 쪼개기**(9.1)을 활용하자.
- 또한 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 이를 위해 **문장 슬라이스**(8.6), **함수 추출하기**(6.1)를 활용하자.
- API를 만들 때는 **질의 함수와 변경 함수 분리하기**(11.1)를 활용해 꼭 필요한 경우가 아니라면 부작용 있는 코드를 호출할 수 없게 만들자.
- **세터 제거하기**(11.7)도 활용하자.
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 **파생 변수를 질의 함수로 바꾸기**(9.3)를 활용하자.
- 변수의 유효 범위가 단 몇 줄이라 해도 추후 범위가 넓어질 수 있다. 이런 경우 **여러 함수를 클래스로 묶기**(6.9), **여러 함수를 변환 함수로 묶기**(6.10)를 활용하자.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**(9.4)를 활용해 내부 필드를 수정하는 대신 구조체를 통재로 교체하자.
- 여기서 말하는 **참조를 값으로 바꾸기**는 불변의 값 객체를 만드는 것
### 1-7. 뒤엉킨 변경
- 뒤엉킨 변경은 SRP가 제대로 지켜지지 않을 때 나타난다.
- 즉, 한 모듈의 변경의 이유가 한 가지가 아니라 여러 가지일 때 나타난다. 
- 순차적으로 실행되는 맥락이라면 다음 맥락에 필요한 데이터를 특정 구조로 전달하는 식의 **단계 쪼개기**(6.11)를 활용하자.
- 전체 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면 각 맥락에 해당하는 적당한 모듈들을 만들어 관련 함수를 모으자(**함수 옮기기**(8.1))
### 1-8. 산탄총 수술
- 산탄총 수술은 뒤엉킨 변경과 비슷하지만 정반대다. 즉, 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때를 의미한다.
- 변경되는 대상들을 **함수 옮기기**(8.1), **필드 옮기기**(8.2)로 한 모듈에 묶어 보자.
- 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**(6.9)를 활용하자.
- 데이터 구조를 변환, 보강하는 함수는 **여러 함수를 변환 함수로 묶기**(6.10)를 적용하자.
- 이렇게 묶은 함수들의 결과를 모아 다음 단계의 로직에 전달할 수 있다면 **단계 쪼개기**(6.11)를 적용하자.
- 어설프게 분리된 로직은 **함수 인라인하기**(6.2), **클래스 인라인 하기**(7.6)를 활용하자.
- 리팩터링 과정에서 함수와 클래스가 큰 덩어리로 뭉쳐질 수 있지만 개의치말자. 단, 작은 함수, 클래스를 지향하는 것이 목표다.
### 1-9. 기능 편애 


## 2. 리뷰
- 