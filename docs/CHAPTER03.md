# Chapter03 - 코드에서 나는 악취

## 1. 요약
리팩터링을 언제 시작하고, 언제 그만할지를 판단하는 일은 매우 중요하다. 
명확하게 정립된 규칙은 없지만 저자와 켄트 벡은 '냄새'라는 표현으로 리팩터링할 시점을 정립한다.
언제 멈출지에 대한 기준은 제시하지 않는다. 다만, 숙련된 사람의 직관이 가장 정확한 기준이 될 것이다. 
### 1-1. 기이한 이름
- 코드는 단순 명료하게 작성해야 하며, 이를 위해선 '이름'이 가장 중요한 요소다. 
- 그 이유는 이름만 잘 지어도 나중에 코드 문맥을 쉽게 파악할 수 있기 때문이다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 존재할 가능성이 높다. 
### 1-2. 중복 코드
- 코드가 중복되면 각각의 차이점을 주의깊게 살펴야 하는 부담이 생긴다. 
- 코드가 중복될 땐, **함수 추출하기**(6.1)와 같은 기법을 적용하자.
- 만약 비슷한데 완전히 똑같지 않다면 비슷한 부분을 **문장 슬라이스**(8.6)로 모아 함수 추출을 하자.
- 자식 클래스들에 코드가 중복되어 있다면 각자 호출되지 않도록 **메서드 올리기**(12.1)를 적용하자.
### 1-3. 긴 함수
- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
- 이러한 코드는 끝없이 위임하는 방식으로 구성되어 있다. 
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 이 부분에서도 역시 '이름'이 중요한 요소다.
- 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다.
- 무엇을 하는지를 코드가 잘 설명 못할수록 함수로 만드는 것이 유리하다.
- 함수 추출하기에 가장 방해되는 것은 매개 변수와 임시 변수다. 
- 함수 추출하기에 앞서 **임시 변수를 질의 함수로 바꾸기**(7.4), **매개변수 객체 만들기**(6.8), **객체 통째로 넘기기**(11.9)를 선행하자.
- 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많고, 이러한 부분이 함수로 추출하기에 적합한 부분이다.
- 반복문을 함수로 추출하여 이름 짓기가 어려운 것은 성격이 다른 두 가지 작업이 섞여 있기 때문이다.
### 1-4. 긴 매개변수 목록
- 매개 변수 목록이 길어지면 이해하기 어려운 경우가 많다. 
- **매개변수를 질의 함수로 바꾸기**(11.5) 또는 객체 전달을 활용하자.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 **플래그 인수 제거하기**(11.3)로 없애자.
- 여러 개의 함수가 특정 매개변수의 값을 공통적으로 사용한다면 **여러 함수를 클래스로 묶기**(6.9)를 활용하자.
### 1-5. 전역 데이터
- 전역 데이터는 코드베이스 어디서든 접근 가능하고, 누가 값을 바꿨는지 찾아낼 메커니즘이 없다.
- 전역 데이터가 가변이라면 특히 다루기 까다롭다.
- 이를 방지하기 위한 대표적인 리팩터링은 **변수 캡슐화 하기**(6.6)다.
- 또한 언어 레벨에서 값이 바뀌지 않음을 보장하는 기능이 존재해야 한다.
### 1-6. 가변 데이터
- 데이터 변경 후 예상하지 못한 곳에서 버그가 발생하는 경우가 종종 있다.
- 아주 드문 조건에서만 발생하다면 더욱 원인을 알아내기 어렵다. 
- **변수 캡슐화 하기**(6.6)을 적용해 함수를 거쳐야만 값을 수정할 수 있도록 하자.
- 하나의 변수에 용도가 다른 값을 저장하기 위해 값을 변경한다면 **변수 쪼개기**(9.1)을 활용하자.
- 또한 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 이를 위해 **문장 슬라이스**(8.6), **함수 추출하기**(6.1)를 활용하자.
- API를 만들 때는 **질의 함수와 변경 함수 분리하기**(11.1)를 활용해 꼭 필요한 경우가 아니라면 부작용 있는 코드를 호출할 수 없게 만들자.
- **세터 제거하기**(11.7)도 활용하자.
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 **파생 변수를 질의 함수로 바꾸기**(9.3)를 활용하자.
- 변수의 유효 범위가 단 몇 줄이라 해도 추후 범위가 넓어질 수 있다. 이런 경우 **여러 함수를 클래스로 묶기**(6.9), **여러 함수를 변환 함수로 묶기**(6.10)를 활용하자.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 일반적으로 **참조를 값으로 바꾸기**(9.4)를 활용해 내부 필드를 수정하는 대신 구조체를 통재로 교체하자.
- 여기서 말하는 **참조를 값으로 바꾸기**는 불변의 값 객체를 만드는 것
### 1-7. 뒤엉킨 변경
- 뒤엉킨 변경은 SRP가 제대로 지켜지지 않을 때 나타난다.
- 즉, 한 모듈의 변경의 이유가 한 가지가 아니라 여러 가지일 때 나타난다. 
- 순차적으로 실행되는 맥락이라면 다음 맥락에 필요한 데이터를 특정 구조로 전달하는 식의 **단계 쪼개기**(6.11)를 활용하자.
- 전체 과정에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면 각 맥락에 해당하는 적당한 모듈들을 만들어 관련 함수를 모으자(**함수 옮기기**(8.1))
### 1-8. 산탄총 수술
- 산탄총 수술은 뒤엉킨 변경과 비슷하지만 정반대다. 즉, 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때를 의미한다.
- 변경되는 대상들을 **함수 옮기기**(8.1), **필드 옮기기**(8.2)로 한 모듈에 묶어 보자.
- 비슷한 데이터를 다루는 함수가 많다면 **여러 함수를 클래스로 묶기**(6.9)를 활용하자.
- 데이터 구조를 변환, 보강하는 함수는 **여러 함수를 변환 함수로 묶기**(6.10)를 적용하자.
- 이렇게 묶은 함수들의 결과를 모아 다음 단계의 로직에 전달할 수 있다면 **단계 쪼개기**(6.11)를 적용하자.
- 어설프게 분리된 로직은 **함수 인라인하기**(6.2), **클래스 인라인 하기**(7.6)를 활용하자.
- 리팩터링 과정에서 함수와 클래스가 큰 덩어리로 뭉쳐질 수 있지만 개의치말자. 단, 작은 함수, 클래스를 지향하는 것이 목표다.
### 1-9. 기능 편애 
- 모듈을 구축할 땐 내부에서의 상호 작용은 최대한 늘리고, 외부와의 상호 작용은 최소로 줄여야 한다.
- 이 때, 어떤 함수가 자기가 속한 모듈보다 다른 모듈의 함수 or 데이터와 상호 작용을 더하는 경우가 있다. 이를 '기능 편애'라고 한다.
- 디미터 법칙을 위반하는 getter 모음은 **함수 옮기기**(8.1)를 활용한다.
- 만약 특정 함수의 일부에서만 기능 편애가 발생한다면 **함수 추출하기**(6.1)로 상호 작용이 많은 모듈로 보내주자.
- 애매한 경우, 가장 많은 데이터를 포함하는 모듈로 옮겨주자.
- 위의 규칙을 거스르며 기능 편애를 해결하는 패턴으로는 전략, 방문자 패턴과 켄트 벡의 자기 위임이 있다. 
- 이 또한 결국 '함께 변경할 대상을 한데 모으는 것'이라는 기본 원칙을 가진다. 
### 1-10. 데이터 뭉치
- 몰려다니는 데이터 뭉치는 모듈화 하자.
- 먼저 필트 형태의 데이터 뭉치를 찾아 **클래스 추출하기**(7.5)로 묶자.
- 다음 메서드 시그니처에 존재하는 데이터 뭉치는 **매개변수 객체 만들기**(6.8)이나 **객체 통째로 넘기기**(11.4)를 적용해 매개 변수를 줄여 보자. 
- 데이터 뭉치를 판별하려면 값 하나를 삭제하고, 나머지 데이터만으로 의미가 없는지를 확인하자.
### 1-11. 기본형 집착(기본 타입에 대한 강박 관념)
- 자신의 상황에 맞는 기초 타입을 직접 정의해 사용하자.(화폐, 좌표, 구간 등)
- **기본형을 객체로 바꾸기**(7.3)를 적용해 기본 타입이 가진 한계를 부시고, 메세지를 주고 받고 능동적인 객체를 만들자.
- 만약 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 **타입 코드를 서브 클래스로 바꾸기**(12.6)와 **조건부 로직을 다형성으로 바꾸기**(10.4)를 활용하자.
### 1-12. 반복되는 switch문
- switch문 == 다형성의 신호는 무조건적이 아니다.
- 대신 같은 조건부 로직(switch or if-else)이 여러 곳에서 반복해 등장하는 경우를 더 신경 쓰자
### 1-13. 반복문
- **반복문을 파이프라인으로 바꾸기**(8.8)을 활용해 반복문을 제거하자. (일급 함수를 활용하기)
### 1-14. 성의 없는 요소
- 의미 없는 클래스, 함수, 인터페이스 등 과거의 상태가 어떻든 현재 상태가 빈약한 요소는 아래 방식을 활용해 제거하자.
- **함수 인라인하기**(6.2), **클래스 인라인하기**(7.6), **계층 합치기**(12.9)
### 1-15. 추측성 일반화
- 이 냄새는 '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트, 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.
- 이러한 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다.(테스트 삭제 후 **죽은 코드 제거하기**(8.9))
- 즉, 당장 걸리적거리는 코드는 눈앞에서 치워버리자.
- 1-14의 기법들에 더해 **함수 선언 바꾸기**(6.5)로 없애자. 
### 1-16. 임시 필드
- 특정 상황에서만 값이 설정되는 필드를 가진 클래스들은 **클래스 추출하기**(7.5)로 빈 값인 필드들을 따로 모아주자.
- 이후 **함수 옮기기**(8.1)로 임시 필드와 관련된 코드를 모조리 새 클래스에 몰아 넣자. 
- 만약 옮겨진 임시 필드들이 유효한지 검증 후 동작하는 조건부 로직이 존재하면, **특이 케이스 추가하기**(10.5)로 대안 클래스를 만들어 제거하자. 
### 1-17. 메시지 체인
- 이 냄새는 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 이는 클라이언트가 객체 네비게이션 구조에 종속됐음을 의미한다. 
- 최종 결과 객체의 쓰임새를 파악한 후, 중간 객체들이 중개자(3.18)가 되지 않는 방향에서 **위임 숨기기**(7.7)로 해결하자.
### 1-18. 중개자
- 캡슐화하는 과정에서 위임이 자주 활용되는데 과한 경우엔 문제가 된다.
- 이럴 땐 **중개자 제거하기**(7.8)를 활용해 실제 일을 하는 객체와 직접 소통하게 만들자.
### 1-19. 내부자 거래
- 1-9와 비슷하지만 은밀히 데이터를 주고 받는 경우를 의미하는 듯하다.(개인 생각)
- 만약 상속 구조에서 부모-자식 사이의 결합도가 높아진다면 **서브클래스를 위임으로 바꾸기**(12.10)이나 **슈퍼 클래스를 위임으로 바꾸기**(12.11)를 활용하자.
### 1-20. 거대한 클래스
- 한 클래스가 너무 많은 일을 하면 필드가 늘어나고, 필드가 많을수록 중복 코드가 생기기 쉽다.
- **클래스 추출하기**(7.5)를 활용해 성질이 비슷한 필드를 따로 묶자.(접두어, 접미어가 같은 경우가 대개 그렇다)
- 만약 계층 구조로 만드는게 유리하다면 **슈퍼클래스 추출하기**(12.8)나 **타입 코드를 서브 클래스로 바꾸기**(12.6)를 활용하자. 
- 클라이언트가 거대 클래스를 이용하는 패턴을 분석해 거대 클래스를 쪼갤 단서를 얻을 수 있다. 
### 1-21. 서로 다른 인터페이스의 대안 클래스들
- 클래스 사용의 가장 큰 장점은 다른 클래스로 대체 가능하다는 것이다. 
- 물론 교체하려면 인터페이스가 같아야 한다. 이를 위해 **함수 선언 바꾸기**(6.5), **함수 옮기기**(8.1)을 활용해 인터페이스를 일치시키자.
- 과정 중에 대안 클래스 사이에 중복 코드가 생기면 **슈퍼클래스 추출하기**(12.8)를 활용해보자.
### 1-22. 데이터 클래스
- 데이터 클래스란 필드, getter/setter로만 구성된 클래스를 의미한다.(record)
- 그저 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다. 
- 이런 클래스에 public 필드가 있다면 **레코드 캡슐화하기**(7.1)로 숨기자.
- 다른 클래스에서 데이터 클래스의 getter/setter를 사용하는 메서드를 찾아 **함수 옮기기**(8.1)로 데이터 클래스에 메서드를 옮기자.
- 만약 옮기기 어렵다면 **함수 추출하기**(6.1)를 이용해 옮길 수 있는 부분만 별도 메서드로 뽑아내자.
- 데이터 클래스는 종종 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수도 있다. 이 경우 클라이언트 코드를 데이터 클래스로 옮겨보자.
- 만약 중간 단계에서 불변의 형태로 데이터를 옮기기만 한다면 필드 자체를 공개해도 좋다.
### 1-23. 상속 포기
- 부모 클래스의 모든 요소가 필요하지 않다면 같은 계층에 서브 클래스를 하나 만들고, **메서드 내리기**(12.4)와 **필드 내리기**(12.5)를 활용해 부모 클래스를 분리하자.
- 상속 포기 냄새는 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다. 
- 이런 경우엔 **서브클래스를 위임으로 바꾸기**(12.10), **슈퍼클래스를 위임으로 바꾸기**(12.11)를 활용하자.
### 1-24
- 주석은 악취가 아닌 향기를 입힌다. 문제는 탈취제처럼 사용하는 경우다.
- 특정 코드 블록이 하는 일에 주석을 남기고 싶다면 **함수 추출하기**(6.1)를 적용하자.
- 이미 추출되어 있는 함수임에도 설명이 필요하다면 **함수 선언 바꾸기**(6.5)를 적용하자.
- 시스템이 동작하기 위한 선행 조건을 명시하고 싶다면 **어서션 추가하기**(10.6)를 적용하자.
- 즉, 주석이 필요하다고 생각이 들면 일단 주석이 필요 없는 코드로 리팩터링 해봐야 한다.

## 2. 리뷰
- 